from matplotlib import pyplot  
# import scipy as sp    
import cupy as np
import numpy as npp
import pandas as pd
from matplotlib import pylab  
from sklearn.datasets import load_files   
from sklearn.feature_extraction.text import  CountVectorizer  
from sklearn.feature_extraction.text import  TfidfVectorizer  
from sklearn.naive_bayes import MultinomialNB  
from sklearn.metrics import precision_recall_curve, roc_curve, auc  
from sklearn.metrics import classification_report  
from sklearn.metrics import confusion_matrix
from sklearn.linear_model import LogisticRegression  
import time 
# from scipy.linalg.misc import norm
from copy import deepcopy
# from numpy import *
import os
np.set_printoptions(threshold=np.inf) 
from sklearn.metrics import roc_auc_score, roc_curve, auc 
from sklearn import metrics 
import time
from sklearn.metrics import classification_report, average_precision_score
from sklearn.linear_model import LogisticRegression 
os.environ['CUDA_VISIBLE_DEVICES']='1'
import torch
from torch.autograd import Variable
from torch import nn, optim
from torch.utils.data import DataLoader
from torchvision.utils import save_image
import os
import pickle
from DeepNeuralNetworkforADDIPredicton import DeepNeuralNetworkForADDIModeling
from DeepNeuralNetworkforADDIPredicton import LossFunctionOfPredictedAndGroundTruthAdverseInteractionVector
device=torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)
os.environ['CUDA_VISIBLE_DEVICES']='0'
Threshold_PredictADDI=0.5
torch.manual_seed(1)
torch.cuda.manual_seed(1)
npp.random.seed(1) # 用于numpy的随机数
np.random.seed(1)
torch.cuda.manual_seed_all(1)

# This class is used to record the adverse interactions among adverse drug pair, 
# in which DrugID1 and DrugID2 are the drug indexes in the adverse drug pair, and 
# AdverseInteractionVector is the ground-truth adverse interaction vector caused by 
# (DrugID1,DrugID2) adverse drug pair. The length of AdverseInteractionVector is equal to
# AdverseInteractionLength in MultiAttributeLearningForADDIPrediction.py
class AdverseInteraction:
    def __init__(self,DrugID1,DrugID2,AdverseInteractionVector):
    	# i.e., (d_i, d_j, r_{ij}^K) in the paper, d_i=DrugID, d_j=DrugID2, 
    	# r_{ij}^K=AdverseInteractionVector
        self.DrugID1 = DrugID1 
        self.DrugID2 = DrugID2
        self.AdverseInteractionVector=AdverseInteractionVector

    # to store the Kernel Vector generated by 384 kernels
    def AddKernelVectorbyOriginalKernels(self,OriginalKernelVectorP,
    	OriginalKernelVectorQ):
    	self.OriginalKernelVectorP=OriginalKernelVectorP
    	self.OriginalKernelVectorQ=OriginalKernelVectorQ

    # to generate Kernel Vector by Representative Kernels
    # this Kernel vector is obtained by using the Representative ones to reconstruct
    # the original one
    def AddKernelVectorbyRepresentativeKernels(self,KernelVectorPQ):
    	self.KernelVectorPQ=KernelVectorPQ

def MakeDir(Address):
	if not os.path.exists(Address):
		os.mkdir(Address)

def same_seeds(seeds):
	torch.manual_seed(seeds)
	torch.cuda.manual_seed(seeds)
	npp.random.seed(seeds) # 用于numpy的随机数
	np.random.seed(seeds)
	torch.cuda.manual_seed_all(seeds)

# This function is to randomly select Percentage of adverse interactions among drugs from 
# AdverseInteractionDataset for training, then use the remaining adverse interactions among drugs
# for testing. Given the AdverseInteractionDataset output by function LoadAdverseInteractionData
# and the Percentage for training, the number of adverse interactions for training is 
# Len(LoadAdverseInteractionData)*Percentage, the number of adverse interactions for testing is 
# Len(LoadAdverseInteractionData)*(1-Percentage)
def RandomTrainingSampleAndTestingSampleSeletion(AdverseInteractionDataset, Percentage):
# input AdverseInteractionDataset is the total adverse interaction set
# Percentage is the percentage for training
	AdverseInteractionNum=len(AdverseInteractionDataset)
	# get the number of adverse interactions in AdverseInteractionDataset
	AdverseInteractionTrainingNum=(int)(AdverseInteractionNum*Percentage)
	# get the number of adverse interactions for training
	AdverseInteractionDatasetTemp=deepcopy(AdverseInteractionDataset)
	# get a deep copy from AdverseInteractionDataset 
	# AdverseInteractionDataset and AdverseInteractionDatasetTemp are two individual list 
	AdverseInteractionTrainingList=[]
	# Initialize a list to store the selected adverse interactions for training
	AdverseInteractionTestingList=[]
	# Initialize a list to store the selected adverse interactions for testing
	AdverseInteractionNumTemp=AdverseInteractionNum
	# get a copy from AdverseInteractionNum to record the 
	# number of adverse interactions in the remaining dataset 
	for i in range (AdverseInteractionTrainingNum):
	# traverse from 0 to AdverseInteractionTrainingNum-1 for generating the random index 
	# from AdverseInteractionTrainingNumTemp
		RandomInt=npp.random.randint(0,AdverseInteractionNumTemp)
		# print(RandomInt)
		# get a random number from 0 to AdverseInteractionNumTemp-1
		AdverseInteractionTrainingList.append(AdverseInteractionDatasetTemp[RandomInt])
		# random select a sample with index=RandomInt from AdverseInteractionDatasetTemp
		# as a training sample
		del AdverseInteractionDatasetTemp[RandomInt]
		# delete AdverseInteractionDatasetTemp[RandomInt] from AdverseInteractionDatasetTemp
		AdverseInteractionNumTemp=AdverseInteractionNumTemp-1
		# the number of adverse interactions the remaining dataset 
		# AdverseInteractionNumTemp-1
	AdverseInteractionTestingList=AdverseInteractionDatasetTemp
	# after selecting AdverseInteractionTrainingNum samples from AdverseInteractionDatasetTemp
	# and deleting the selected samples from AdverseInteractionDatasetTemp, the remaining samples 
	# in AdverseInteractionDatasetTemp can be used for testing
	return AdverseInteractionTrainingList,AdverseInteractionTestingList
	# return the training and testing samples


# This function is to load the data of the adverse interactions among drugs from 
# AdverseInteractionSetfromTWOSIDES.txt. To be specific, there are totally 
# 13213650 adverse interactions associated with 752 drugs and 25459 adverse drug pairs and 1307 adverse interactions
# In AdverseInteractionDatasetbyDrugPairAdverseVector.txt, each line records three entries,
# the first two entries is the drug ID of d_i and d_j, the last entry is the adverse interaction 
# vector r_{ij}^K induced by (d_i, d_j), in which if (d_i, d_j) leads to the k-th adverse interactions, 
# the k-th element in vector r_{ij}^K is 1, otherwise 0. The number of adverse interaction,
# i.e., the length of vector r_{ij}^K is denoted as AdverseInteractionLength. In the experiments, 
# AdverseInteractionLength (i.e., K) is set to be 1307
def LoadAdverseInteractionData(AdverseInteractionDataAddress):
# input: AdverseInteractionDataAddress is the address of the adverse interaction data
# AdverseInteractionDataAddress='AdverseInteractionDatasetbyDrugPairAdverseVector.txt'
	AdverseInteractionDataset=[]
	# AdverseInteractiondataset records the all adverse interaction data in the form of 
	# class AdverseInteraction defined above
	fileIn=open(AdverseInteractionDataAddress)
	# open the file AdverseInteractionDatasetbyDrugPairAdverseVector.txt
	line=fileIn.readline()
	# read the first line
	while line:
		lineArr=line.strip().split('\t')
		# Split each line by Tab i.e., \t
		DrugID1=(int)(lineArr[0].strip())
		DrugID2=(int)(lineArr[1].strip())
		# get the first two entries of each line, i.e., the DrugID of the adverse drug pair
		lineSpace=lineArr[2].strip().split() 
		# the last entry is the binary vector splitted by space ' ' being the adverse interaction 
		# vector of (DrugID1,DrugID2). The k-th element represents that whether the k-th adverse 
		# interaction can be caused by (DrugID1,DrugID2). If the k-th adverseinteraction can be caused 
		# by (DrugID1,DrugID2), then the corresponding element is 1, otherwise 0
		AdverseInteractionVector=[]
		# Initialize list AdverseInteractionVector to record the Adverse interaction induced by (DrugID1,DrugID2)
		for i in lineSpace:
			AdverseInteractionVector.append(float(i))
		# append each element into AdverseInteractionVector
		AdverseInteractionVector=np.array(AdverseInteractionVector)
		# convert list AdverseInteractionVector into array
		AdverseInteractionVector=torch.Tensor(AdverseInteractionVector)
		# convert AdverseInteractionVector into Tensor for the convenience of model training in GPU
		ADDISample=AdverseInteraction(DrugID1,DrugID2,AdverseInteractionVector)
		# Initialize an object ADDISample of the class AdverseInteraction 
		# by (DrugID1,DrugID2,AdverseInteractionVector)
		AdverseInteractionDataset.append(ADDISample)
		# append the Initialized object into AdverseInteractionDataset
		line=fileIn.readline()
		# read the next line (i.e., the Adverse interaction of the next adverse drug pair)
	return AdverseInteractionDataset

def LoadP_CommonAttributeMatrixInNPYform(P_CommonAttributeMatrixAddress):
	# this function is to load the Commom attribute representation of drugs
	P_CommonAttributeMatrix=np.load(P_CommonAttributeMatrixAddress)
	return P_CommonAttributeMatrix

def LoadQ_SpecificAttributeMatrixInNPYform(LoadQ_SpecificAttributeMatrixAddress):
	# this function is to load the specific representations of each attribute of drugs
	Q_AttributeMatrix=np.load(LoadQ_SpecificAttributeMatrixAddress)
	return Q_AttributeMatrix

def JointQ_SpecificAttributeofAllDrugs(Q_AttributeMatrix):
	# this function is to joint the Q_Attribute Matrix of All drugs
	AttributeNum=len(Q_AttributeMatrix)
	JointQ_AttributeMatrix=Q_AttributeMatrix[0]
	for Attribute_Index in range(1,AttributeNum):
		JointQ_AttributeMatrix=np.hstack((JointQ_AttributeMatrix,Q_AttributeMatrix[Attribute_Index]))
	# print(np.shape(JointQ_AttributeMatrix))
	return JointQ_AttributeMatrix

def LinearKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate the Linear Kernel Function of two vectors
	# i.e., the cosine function kernels
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	L_2_norm=np.linalg.norm(DrugAttirbuteMatrix,ord=None,axis=1)
	LinearKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		LinearKernelMatrix[DrugID1,DrugID2]=DrugSimilartyMatrix[DrugID1,DrugID2]/(L_2_norm[DrugID1]*L_2_norm[DrugID2])
		LinearKernelMatrix[DrugID2,DrugID1]=DrugSimilartyMatrix[DrugID1,DrugID2]/(L_2_norm[DrugID1]*L_2_norm[DrugID2])
	# LinearKernelMatrix=LinearKernelMatrix/LinearKernelMatrix.max()
	return LinearKernelMatrix

def OutputLinearKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	# this function is to output Linear Kernel Matrix of P and Q matrix
	Address='./LinearKernelFunction/'
	MakeDir(Address)
	LinearKernelMatrixP=LinearKernelFunction(P_CommonAttributeMatrix,AdverseInteractionTrainingList)
	LinearKernelMatrixQ=LinearKernelFunction(JointQ_AttributeMatrix,AdverseInteractionTrainingList)
	np.save(str(Address)+'LinearKernelMatrixP',LinearKernelMatrixP)
	np.savetxt(str(Address)+'LinearKernelMatrixP.txt',LinearKernelMatrixP)
	np.save(str(Address)+'LinearKernelMatrixQ',LinearKernelMatrixQ)
	np.savetxt(str(Address)+'LinearKernelMatrixQ.txt',LinearKernelMatrixQ)

def PolynomialKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,a,b,c):
	# this function is to calculate the PolynomialKernel Function of two vectors
	# i.e., (a+bX^T*Y)^c
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	PolynomialKernelVector=np.power(a+b*DrugSimilartyMatrixDiag,0.5*c)
	
	TempMatrix=np.power(a+b*DrugSimilartyMatrix,c)

	PolynomialKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		PolynomialKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]/(PolynomialKernelVector[DrugID1]*\
			PolynomialKernelVector[DrugID2])
		PolynomialKernelMatrix[DrugID2,DrugID1]=PolynomialKernelMatrix[DrugID1,DrugID2]
	# PolynomialKernelMatrix=PolynomialKernelMatrix/PolynomialKernelMatrix.max()
	return PolynomialKernelMatrix

def OutputPolynomialKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./PolynomialKernelFunction/'
	MakeDir(Address)
	aSet=np.arange(0,5.02,1.0);aSet=np.round(aSet,2)
	bSet=np.arange(1,5.02,1.0); bSet=np.round(bSet,2)
	cSet=np.arange(0.5,2.1,0.5); cSet=np.round(cSet,2)
	for a in aSet:
		for b in bSet:
			for c in cSet:
				PolynomialKernelMatrixP=PolynomialKernelFunction(P_CommonAttributeMatrix,
					AdverseInteractionTrainingList,a,b,c)
				PolynomialKernelMatrixQ=PolynomialKernelFunction(JointQ_AttributeMatrix,
					AdverseInteractionTrainingList,a,b,c)
				np.save(str(Address)+'PolynomialKernelMatrixP'+'a='+str(a)+'b='+str(b)+'c='+str(c),PolynomialKernelMatrixP)
				np.savetxt(str(Address)+'PolynomialKernelMatrixP'+'a='+str(a)+'b='+str(b)+'c='+str(c)+'.txt',PolynomialKernelMatrixP)
				np.save(str(Address)+'PolynomialKernelMatrixQ'+'a='+str(a)+'b='+str(b)+'c='+str(c),PolynomialKernelMatrixQ)
				np.savetxt(str(Address)+'PolynomialKernelMatrixQ'+'a='+str(a)+'b='+str(b)+'c='+str(c)+'.txt',PolynomialKernelMatrixQ)

def GaussianKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,Delta):
	# this function is to calculate the Gaussian Kernel similarity of two vectors
	# i.e., exp(-||X-Y||_2^2/2*Delta^2)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=np.exp(-1*TempMatrix/(2*Delta*Delta))
	GaussianKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		DrugGeneralizedTStudentKernel2MatrixQID2=AdverseInteractionSample.DrugID2
		GaussianKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		GaussianKernelMatrix[DrugID2,DrugID1]=GaussianKernelMatrix[DrugID1,DrugID2]
			
	# GaussianKernelMatrix=GaussianKernelMatrix/GaussianKernelMatrix.max()
	WhereIsNan=np.isnan(GaussianKernelMatrix)
	GaussianKernelMatrix[WhereIsNan]=0.0 
	return GaussianKernelMatrix

def OutputGaussianKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./GaussianKernelFunction/'
	MakeDir(Address)
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		GaussianKernelMatrixP=GaussianKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		GaussianKernelMatrixQ=GaussianKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		np.save(str(Address)+'GaussianKernelMatrixP'+'Delta='+str(Delta),GaussianKernelMatrixP)
		np.savetxt(str(Address)+'GaussianKernelMatrixP'+'Delta='+str(Delta)+'.txt',GaussianKernelMatrixP)

		np.save(str(Address)+'GaussianKernelMatrixQ'+'Delta='+str(Delta),GaussianKernelMatrixQ)
		np.savetxt(str(Address)+'GaussianKernelMatrixQ'+'Delta='+str(Delta)+'.txt',GaussianKernelMatrixQ)


def ExponentialKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,Delta):
	# this function is to calculate Exponential Kernel function and of Laplacian Kernel Function two vectors
	# i.e., Exponential Kernel function: exp(||X-Y||_1/2*Delta^2)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	ExponentialKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		TempValue=np.absolute(DrugAttirbuteMatrix[DrugID1]-DrugAttirbuteMatrix[DrugID2])
		TempValue=np.sum(TempValue)
		ExponentialKernelMatrix[DrugID1,DrugID2]=np.exp(-TempValue/(2*Delta*Delta))
		ExponentialKernelMatrix[DrugID2,DrugID1]=ExponentialKernelMatrix[DrugID1,DrugID2]
	# ExponentialKernelMatrix=ExponentialKernelMatrix/ExponentialKernelMatrix.max()
	WhereIsNan=np.isnan(ExponentialKernelMatrix)
	ExponentialKernelMatrix[WhereIsNan]=0.0 
	return ExponentialKernelMatrix

def OutputExponentialKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./ExponentialKernelFunction/'
	MakeDir(Address)
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		ExponentialKernelMatrixP=ExponentialKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		ExponentialKernelMatrixQ=ExponentialKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		np.save(str(Address)+'ExponentialKernelMatrixP'+'Delta='+str(Delta),ExponentialKernelMatrixP)
		np.savetxt(str(Address)+'ExponentialKernelMatrixP'+'Delta='+str(Delta)+'.txt',ExponentialKernelMatrixP)

		np.save(str(Address)+'ExponentialKernelMatrixQ'+'Delta='+str(Delta),ExponentialKernelMatrixQ)
		np.savetxt(str(Address)+'ExponentialKernelMatrixQ'+'Delta='+str(Delta)+'.txt',ExponentialKernelMatrixQ)


def LaplacianKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,Delta):
	# this function is to calculate Laplacian Kernel Function two vectors
	# i.e., Laplacian Kernel Function: exp(||X-Y||_1/Delta)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	LaplacianKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		TempValue=np.absolute(DrugAttirbuteMatrix[DrugID1]-DrugAttirbuteMatrix[DrugID2])
		TempValue=np.sum(TempValue)
		LaplacianKernelMatrix[DrugID1,DrugID2]=np.exp(-TempValue/Delta)
		LaplacianKernelMatrix[DrugID2,DrugID1]=LaplacianKernelMatrix[DrugID1,DrugID2]
	# LaplacianKernelMatrix=LaplacianKernelMatrix/LaplacianKernelMatrix.max()
	WhereIsNan=np.isnan(LaplacianKernelMatrix)
	LaplacianKernelMatrix[WhereIsNan]=0.0 
	return LaplacianKernelMatrix

def OutputLaplacianKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./LaplacianKernelFunction/'
	MakeDir(Address)
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		LaplacianKernelMatrixP=LaplacianKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		LaplacianKernelMatrixQ=LaplacianKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		np.save(str(Address)+'LaplacianKernelMatrixP'+'Delta='+str(Delta),LaplacianKernelMatrixP)
		np.savetxt(str(Address)+'LaplacianKernelMatrixP'+'Delta='+str(Delta)+'.txt',LaplacianKernelMatrixP)

		np.save(str(Address)+'LaplacianKernelMatrixQ'+'Delta='+str(Delta),LaplacianKernelMatrixQ)
		np.savetxt(str(Address)+'LaplacianKernelMatrixQ'+'Delta='+str(Delta)+'.txt',LaplacianKernelMatrixQ)

def SigmoidKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,a,b):
	# this function is to calculate Sigmoid Kernel Function of two vectors
	# i.e., tanh(a+bX^T*Y)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	DrugSimilartyMatrixDiagElem=a*DrugSimilartyMatrixDiag+b
	FirstTemp=np.exp(DrugSimilartyMatrixDiagElem)
	SecondTemp=np.exp(-DrugSimilartyMatrixDiagElem)
	SigmoidKernelVector=(FirstTemp-SecondTemp)/(FirstTemp+SecondTemp)
	SigmoidKernelVector=np.power(SigmoidKernelVector,0.5)
	WhereIsNan=np.isnan(SigmoidKernelVector)
	SigmoidKernelVector[WhereIsNan]=0.0 

	DrugSimilartyMatrixElem=a*DrugSimilartyMatrix+b
	FirstTemp=np.exp(DrugSimilartyMatrixElem)
	SecondTemp=np.exp(-DrugSimilartyMatrixElem)
	SigmoidKernelMatrixTemp=(FirstTemp-SecondTemp)/(FirstTemp+SecondTemp)
	WhereIsNan=np.isnan(SigmoidKernelMatrixTemp)
	SigmoidKernelMatrixTemp[WhereIsNan]=0
	# SigmoidKernelMatrixTemp=np.where(FirstTemp+SecondTemp!=0,
	# 	SigmoidKernelMatrixTemp,np.zeros_like(SigmoidKernelMatrixTemp))

	SigmoidKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		SigmoidKernelMatrix[DrugID1,DrugID2]=SigmoidKernelMatrixTemp[DrugID1,DrugID2]/(
			SigmoidKernelVector[DrugID1]*SigmoidKernelVector[DrugID2])
		SigmoidKernelMatrix[DrugID2,DrugID1]=SigmoidKernelMatrix[DrugID1,DrugID2]
	# SigmoidKernelMatrix=SigmoidKernelMatrix/SigmoidKernelMatrix.max()
	WhereIsNan=np.isnan(SigmoidKernelMatrix)
	SigmoidKernelMatrix[WhereIsNan]=0.0
	SigmoidKernelMatrix=np.where(SigmoidKernelMatrix!=np.inf,SigmoidKernelMatrix,np.zeros_like(SigmoidKernelMatrix))
	return SigmoidKernelMatrix

def OutputSigmoidKernellMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./SigmoidKernelFunction/'
	MakeDir(Address)
	aSet=[1e-8,5e-8,1e-7,5e-7,1e-6,5e-6,1e-5,5e-5,1e-4,5e-4,1e-3,5e-3]
	bSet=np.arange(0,2.01,0.5); bSet=np.round(bSet,2)
	for a in aSet:
		for b in bSet:
			SigmoidKernelMatrixP=SigmoidKernelFunction(P_CommonAttributeMatrix,
				AdverseInteractionTrainingList,a,b)
			SigmoidKernelMatrixQ=SigmoidKernelFunction(JointQ_AttributeMatrix,
				AdverseInteractionTrainingList,a,b)
			np.save(str(Address)+'SigmoidKernelMatrixP'+'a='+str(a)+'b='+str(b),SigmoidKernelMatrixP)
			np.savetxt(str(Address)+'SigmoidKernelMatrixP'+'a='+str(a)+'b='+str(b)+'.txt',SigmoidKernelMatrixP)

			np.save(str(Address)+'SigmoidKernelMatrixQ'+'a='+str(a)+'b='+str(b),SigmoidKernelMatrixQ)
			np.savetxt(str(Address)+'SigmoidKernelMatrixQ'+'a='+str(a)+'b='+str(b)+'.txt',SigmoidKernelMatrixQ)


def RationalQuadraticKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,c):
	# this function is to calculate Rational Quadratic Kernel:1-||X-Y||_2^2/(||X-Y||_2^2+c)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=1-TempMatrix/(TempMatrix+c)

	RationalQuadraticKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		RationalQuadraticKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		RationalQuadraticKernelMatrix[DrugID2,DrugID1]=RationalQuadraticKernelMatrix[DrugID1,DrugID2]
	# RationalQuadraticKernelMatrix=RationalQuadraticKernelMatrix/RationalQuadraticKernelMatrix.max()
	WhereIsNan=np.isnan(RationalQuadraticKernelMatrix)
	RationalQuadraticKernelMatrix[WhereIsNan]=0.0 
	return RationalQuadraticKernelMatrix

def OutputRationalQuadraticKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./RationalQuadraticKernelFunction/'
	MakeDir(Address)
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		RationalQuadraticKernelMatrixP=RationalQuadraticKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,c)
		RationalQuadraticKernelMatrixQ=RationalQuadraticKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,c)
		np.save(str(Address)+'RationalQuadraticKernelMatrixP'+'c='+str(c),RationalQuadraticKernelMatrixP)
		np.savetxt(str(Address)+'RationalQuadraticKernelMatrixP'+'c='+str(c)+'.txt',RationalQuadraticKernelMatrixP)

		np.save(str(Address)+'RationalQuadraticKernelMatrixQ'+'c='+str(c),RationalQuadraticKernelMatrixQ)
		np.savetxt(str(Address)+'RationalQuadraticKernelMatrixQ'+'c='+str(c)+'.txt',RationalQuadraticKernelMatrixQ)



def MultiquadricKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,c):
	# this function is to calculate Multiquadric Kernel: (||X-Y||_2^2+c*c)^0.5
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=np.power(TempMatrix+c*c,0.5)

	MultiquadricKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		MultiquadricKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		MultiquadricKernelMatrix[DrugID2,DrugID1]=MultiquadricKernelMatrix[DrugID1,DrugID2]
	# MultiquadricKernelMatrix=MultiquadricKernelMatrix/MultiquadricKernelMatrix.max()
	WhereIsNan=np.isnan(MultiquadricKernelMatrix)
	MultiquadricKernelMatrix[WhereIsNan]=0.0
	return MultiquadricKernelMatrix

def OutputMultiquadricKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./MultiquadricKernelFunction/'
	MakeDir(Address)
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		MultiquadricKernelMatrixP=MultiquadricKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,c)
		MultiquadricKernelMatrixQ=MultiquadricKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,c)
		np.save(str(Address)+'MultiquadricKernelMatrixP'+'c='+str(c),MultiquadricKernelMatrixP)
		np.savetxt(str(Address)+'MultiquadricKernelMatrixP'+'c='+str(c)+'.txt',MultiquadricKernelMatrixP)

		np.save(str(Address)+'MultiquadricKernelMatrixQ'+'c='+str(c),MultiquadricKernelMatrixQ)
		np.savetxt(str(Address)+'MultiquadricKernelMatrixQ'+'c='+str(c)+'.txt',MultiquadricKernelMatrixQ)



def InverseMultiquadricKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,c):
	# this function is to calculate Inverse Multiquadric Kernel: (||X-Y||_2^2+c*c)^-0.5
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=np.power(TempMatrix+c*c,-0.5)
	InverseMultiquadricKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		InverseMultiquadricKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		InverseMultiquadricKernelMatrix[DrugID2,DrugID1]=InverseMultiquadricKernelMatrix[DrugID1,DrugID2]
	# InverseMultiquadricKernelMatrix=InverseMultiquadricKernelMatrix/InverseMultiquadricKernelMatrix.max()
	WhereIsNan=np.isnan(InverseMultiquadricKernelMatrix)
	InverseMultiquadricKernelMatrix[WhereIsNan]=0.0
	return InverseMultiquadricKernelMatrix

def OutputInverseMultiquadricKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./InverseMultiquadricKernelFunction/'
	MakeDir(Address)
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		InverseMultiquadricKernelMatrixP=InverseMultiquadricKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,c)
		InverseMultiquadricKernelMatrixQ=InverseMultiquadricKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,c)
		np.save(str(Address)+'InverseMultiquadricKernelMatrixP'+'c='+str(c),InverseMultiquadricKernelMatrixP)
		np.savetxt(str(Address)+'InverseMultiquadricKernelMatrixP'+'c='+str(c)+'.txt',InverseMultiquadricKernelMatrixP)

		np.save(str(Address)+'InverseMultiquadricKernelMatrixQ'+'c='+str(c),InverseMultiquadricKernelMatrixQ)
		np.savetxt(str(Address)+'InverseMultiquadricKernelMatrixQ'+'c='+str(c)+'.txt',InverseMultiquadricKernelMatrixQ)




def SphericalKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,Delta):
	# this function is to calculate Spherical Kernel Function of two vectors
	# i.e., 1-1.5*||X-Y||_1/Delta+0.5(||X-Y||_1/Delta)^3
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	SphericalKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		TempValue=np.absolute(DrugAttirbuteMatrix[DrugID1]-DrugAttirbuteMatrix[DrugID2])
		TempValue1=1.5*np.sum(TempValue)/Delta
		TempValue2=0.5*np.power(np.sum(TempValue)/Delta,3)
		SphericalKernelMatrix[DrugID1,DrugID2]=1-TempValue1+TempValue2
		SphericalKernelMatrix[DrugID2,DrugID1]=SphericalKernelMatrix[DrugID1,DrugID2]

	# SphericalKernelMatrix=SphericalKernelMatrix/SphericalKernelMatrix.max()
	WhereIsNan=np.isnan(SphericalKernelMatrix)
	SphericalKernelMatrix[WhereIsNan]=0.0
	return SphericalKernelMatrix


def OutputSphericalKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./SphericalKernelFunction/'
	MakeDir(Address)
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		SphericalKernelMatrixP=SphericalKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		SphericalKernelMatrixQ=SphericalKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		np.save(str(Address)+'SphericalKernelMatrixP'+'Delta='+str(Delta),SphericalKernelMatrixP)
		np.savetxt(str(Address)+'SphericalKernelMatrixP'+'Delta='+str(Delta)+'.txt',SphericalKernelMatrixP)

		np.save(str(Address)+'SphericalKernelMatrixQ'+'Delta='+str(Delta),SphericalKernelMatrixQ)
		np.savetxt(str(Address)+'SphericalKernelMatrixQ'+'Delta='+str(Delta)+'.txt',SphericalKernelMatrixQ)


def LogKernelFunction1(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate Log Kernel Function1 of two vectors
	# i.e., -log(1+||x-y||_1)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	LogKernelFunction1Matrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		TempValue=np.absolute(DrugAttirbuteMatrix[DrugID1]-DrugAttirbuteMatrix[DrugID2])
		TempValue=np.sum(TempValue)+1
		# LogKernelFunction1Matrix[DrugID1,DrugID2]=-np.log(TempValue)
		LogKernelFunction1Matrix[DrugID1,DrugID2]=np.log(TempValue)
		LogKernelFunction1Matrix[DrugID2,DrugID1]=LogKernelFunction1Matrix[DrugID1,DrugID2]
	# LogKernelFunction1Matrix=LogKernelFunction1Matrix/LogKernelFunction1Matrix.max()
	WhereIsNan=np.isnan(LogKernelFunction1Matrix)
	LogKernelFunction1Matrix[WhereIsNan]=0.0
	return LogKernelFunction1Matrix

def OutputLogKernelFunction1Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./LogKernelFunction1/'
	MakeDir(Address)

	LogKernelFunction1MatrixP=LogKernelFunction1(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	LogKernelFunction1MatrixQ=LogKernelFunction1(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'LogKernelFunction1MatrixP',LogKernelFunction1MatrixP)
	np.savetxt(str(Address)+'LogKernelFunction1MatrixP.txt',LogKernelFunction1MatrixP)

	np.save(str(Address)+'LogKernelFunction1MatrixQ',LogKernelFunction1MatrixQ)
	np.savetxt(str(Address)+'LogKernelFunction1MatrixQ.txt',LogKernelFunction1MatrixQ)


def LogKernelFunction2(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate Log Kernel Function2 of two vectors
	# i.e., -log(1+||x-y||_2^2)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	# TempMatrix=-np.log(1+TempMatrix)
	TempMatrix=np.log(1+TempMatrix)

	LogKernelFunction2Matrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		LogKernelFunction2Matrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		LogKernelFunction2Matrix[DrugID2,DrugID1]=LogKernelFunction2Matrix[DrugID1,DrugID2]
	# LogKernelFunction2Matrix=LogKernelFunction2Matrix/LogKernelFunction2Matrix.max()
	WhereIsNan=np.isnan(LogKernelFunction2Matrix)
	LogKernelFunction2Matrix[WhereIsNan]=0.0
	return LogKernelFunction2Matrix

def OutputLogKernelFunction2Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./LogKernelFunction2/'
	MakeDir(Address)
	LogKernelFunction2MatrixP=LogKernelFunction2(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	LogKernelFunction2MatrixQ=LogKernelFunction2(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'LogKernelFunction2MatrixP',LogKernelFunction2MatrixP)
	np.savetxt(str(Address)+'LogKernelFunction2MatrixP.txt',LogKernelFunction2MatrixP)

	np.save(str(Address)+'LogKernelFunction2MatrixQ',LogKernelFunction2MatrixQ)
	np.savetxt(str(Address)+'LogKernelFunction2MatrixQ.txt',LogKernelFunction2MatrixQ)



def SplineKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# https://blog.csdn.net/mogebuyi/article/details/83243850
	DrugNum,TotalDimention=np.shape(DrugAttirbuteMatrix)
	TempVector=np.zeros(DrugNum)
	for DrugIndex in range(DrugNum):
		Product=1
		for DimensionIndex in range(TotalDimention):
			TempValue=1+np.power(DrugAttirbuteMatrix[DrugIndex,DimensionIndex],2)+np.power(
				DrugAttirbuteMatrix[DrugIndex,DimensionIndex],3)/3
			Product=Product*TempValue
		TempVector[DrugIndex]=np.power(Product,0.5)

	SplineKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		Vector1=DrugAttirbuteMatrix[DrugID1]
		Vector2=DrugAttirbuteMatrix[DrugID2]
		Vector3=np.vstack((Vector1,Vector2)).min(0)
		Product=1
		for Index in range(TotalDimention):
			TempValue=1+Vector1[Index]*Vector2[Index]+Vector1[Index]*Vector2[Index]*Vector3[Index]-\
				0.5*(Vector1[Index]+Vector2[Index])*Vector3[Index]*Vector3[Index]+np.power(Vector3[Index],3)/3
			Product=Product*TempValue
		SplineKernelMatrix[DrugID1,DrugID2]=Product/(TempVector[DrugID1]*TempVector[DrugID2])
		SplineKernelMatrix[DrugID2,DrugID1]=SplineKernelMatrix[DrugID1,DrugID2]
	
	# SplineKernelMatrix=SplineKernelMatrix/SplineKernelMatrix.max()
	WhereIsNan=np.isnan(SplineKernelMatrix)
	SplineKernelMatrix[WhereIsNan]=0.0
	return SplineKernelMatrix

def OutputSplineKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./SplineKernelFunction/'
	MakeDir(Address)
	SplineKernelMatrixP=SplineKernelFunction(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	SplineKernelMatrixQ=SplineKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'SplineKernelMatrixP',SplineKernelMatrixP)
	np.savetxt(str(Address)+'SplineKernelMatrixP.txt',SplineKernelMatrixP)

	np.save(str(Address)+'SplineKernelMatrixQ',SplineKernelMatrixQ)
	np.savetxt(str(Address)+'SplineKernelMatrixQ.txt',SplineKernelMatrixQ)


def CauchyKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,Delta):
	# this function is to calculate Cauchy Kernel Function of two vectors
	# i.e., 1/(||X-Y||_2^2/Delta+1)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=1/(1+TempMatrix/(Delta*Delta))

	CauchyKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		CauchyKernelMatrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		CauchyKernelMatrix[DrugID2,DrugID1]=CauchyKernelMatrix[DrugID1,DrugID2]
	# CauchyKernelMatrix=CauchyKernelMatrix/CauchyKernelMatrix.max()
	WhereIsNan=np.isnan(CauchyKernelMatrix)
	CauchyKernelMatrix[WhereIsNan]=0.0
	return CauchyKernelMatrix


def OutputCauchyKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./CauchyKernelFunction/'
	MakeDir(Address)
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		CauchyKernelMatrixP=CauchyKernelFunction(P_CommonAttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		CauchyKernelMatrixQ=CauchyKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList,Delta)
		np.save(str(Address)+'CauchyKernelMatrixP'+'Delta='+str(Delta),CauchyKernelMatrixP)
		np.savetxt(str(Address)+'CauchyKernelMatrixP'+'Delta='+str(Delta)+'.txt',CauchyKernelMatrixP)

		np.save(str(Address)+'CauchyKernelMatrixQ'+'Delta='+str(Delta),CauchyKernelMatrixQ)
		np.savetxt(str(Address)+'CauchyKernelMatrixQ'+'Delta='+str(Delta)+'.txt',CauchyKernelMatrixQ)


def ChiSquareKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate the Chi Square Kernel Function of two vectors
	# i.e., \sum 2X_i*Y_i/(X_i+Y_i)
	DrugNum,TotalDimention=np.shape(DrugAttirbuteMatrix)
	ChiSquareKernelMatrix=np.zeros((DrugNum,DrugNum))
	# Count=0
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		Vector1=DrugAttirbuteMatrix[DrugID1]
		Vector2=DrugAttirbuteMatrix[DrugID2]
		Vector3=Vector1+Vector2
		Sum=0
		for Index in range(TotalDimention):
			Sum=Sum+2*Vector1[Index]*Vector2[Index]/Vector3[Index]
		ChiSquareKernelMatrix[DrugID1,DrugID2]=Sum
		ChiSquareKernelMatrix[DrugID2,DrugID1]=ChiSquareKernelMatrix[DrugID1,DrugID2]
	# ChiSquareKernelMatrix=ChiSquareKernelMatrix/ChiSquareKernelMatrix.max()
	WhereIsNan=np.isnan(ChiSquareKernelMatrix)
	ChiSquareKernelMatrix[WhereIsNan]=0.0
	return ChiSquareKernelMatrix


def OutputChiSquareKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./ChiSquareKernelFunction/'
	MakeDir(Address)
	ChiSquareKernelMatrixP=ChiSquareKernelFunction(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	np.save(str(Address)+'ChiSquareKernelMatrixP',ChiSquareKernelMatrixP)
	np.savetxt(str(Address)+'ChiSquareKernelMatrixP.txt',ChiSquareKernelMatrixP)
	
	ChiSquareKernelMatrixQ=ChiSquareKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)\

	np.save(str(Address)+'ChiSquareKernelMatrixQ',ChiSquareKernelMatrixQ)
	np.savetxt(str(Address)+'ChiSquareKernelMatrixQ.txt',ChiSquareKernelMatrixQ)


def HistogramIntersectionKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# \sum min(X_i.Y_i)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	SumVector=np.sum(DrugAttirbuteMatrix,axis=1)
	SumVector=np.power(SumVector,0.5)

	HistogramIntersectionKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		Vector1=DrugAttirbuteMatrix[DrugID1]
		Vector2=DrugAttirbuteMatrix[DrugID2]
		Vector3=np.vstack((Vector1,Vector2)).min(0)
		HistogramIntersectionKernelMatrix[DrugID1,DrugID2]=np.sum(Vector3)/(SumVector[DrugID1]*SumVector[DrugID2])
		HistogramIntersectionKernelMatrix[DrugID2,DrugID1]=HistogramIntersectionKernelMatrix[DrugID1,DrugID2]
	# HistogramIntersectionKernelMatrix=HistogramIntersectionKernelMatrix/HistogramIntersectionKernelMatrix.max()
	WhereIsNan=np.isnan(HistogramIntersectionKernelMatrix)
	HistogramIntersectionKernelMatrix[WhereIsNan]=0.0
	return HistogramIntersectionKernelMatrix

def OutputHistogramIntersectionKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./HistogramIntersectionKernelFunction/'
	MakeDir(Address)
	HistogramIntersectionKernelMatrixP=HistogramIntersectionKernelFunction(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	HistogramIntersectionKernelMatrixQ=HistogramIntersectionKernelFunction(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'HistogramIntersectionKernelMatrixP',HistogramIntersectionKernelMatrixP)
	np.savetxt(str(Address)+'HistogramIntersectionKernelMatrixP.txt',HistogramIntersectionKernelMatrixP)

	np.save(str(Address)+'HistogramIntersectionKernelMatrixQ',HistogramIntersectionKernelMatrixQ)
	np.savetxt(str(Address)+'HistogramIntersectionKernelMatrixQ.txt',HistogramIntersectionKernelMatrixQ)


def GeneralizedHistogramIntersectionKernelFunction(DrugAttirbuteMatrix,AdverseInteractionTrainingList,
	alpha,beta):
	# this function os to calculate Generalized Histogram Intersection Kernel Function
	# of two vectors. i.e., \sum min(abs(X_i)^alpha, abs(Y_i)^beta)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugAttirbuteMatrixAbs=np.absolute(DrugAttirbuteMatrix)
	DrugAttirbuteMatrixPoweralpha=np.power(DrugAttirbuteMatrixAbs,alpha)
	DrugAttirbuteMatrixPowerbeta=np.power(DrugAttirbuteMatrixAbs,beta)
	SumVectoralpha=np.power(np.sum(DrugAttirbuteMatrixPoweralpha,axis=1),0.5)
	SumVectorbeta=np.power(np.sum(DrugAttirbuteMatrixPowerbeta,axis=1),0.5)
	GeneralizedHistogramIntersectionKernelMatrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		Vector1=DrugAttirbuteMatrixPoweralpha[DrugID1]
		Vector2=DrugAttirbuteMatrixPowerbeta[DrugID2]
		Vector3=np.vstack((Vector1,Vector2)).min(0)
		GeneralizedHistogramIntersectionKernelMatrix[DrugID1,DrugID2]=\
			np.sum(Vector3)/np.power(np.sum(Vector1)*np.sum(Vector2),0.5)
		GeneralizedHistogramIntersectionKernelMatrix[DrugID2,DrugID1]=\
			np.sum(Vector3)/(SumVectoralpha[DrugID1]*SumVectorbeta[DrugID2])
	# GeneralizedHistogramIntersectionKernelMatrix=GeneralizedHistogramIntersectionKernelMatrix/GeneralizedHistogramIntersectionKernelMatrix.max()
	WhereIsNan=np.isnan(GeneralizedHistogramIntersectionKernelMatrix)
	GeneralizedHistogramIntersectionKernelMatrix[WhereIsNan]=0.0
	return GeneralizedHistogramIntersectionKernelMatrix

def OutputGeneralizedHistogramIntersectionKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./GeneralizedHistogramIntersectionKernelFunction/'
	MakeDir(Address)
	alphaSet=np.arange(0.1,2.01,0.2); alphaSet=np.round(alphaSet,2)
	betaSet=np.arange(0.1,2.01,0.2); betaSet=np.round(betaSet,2)
	for alpha in alphaSet:
		for beta in betaSet:
			GeneralizedHistogramIntersectionKernelMatrixP=GeneralizedHistogramIntersectionKernelFunction(P_CommonAttributeMatrix,
				AdverseInteractionTrainingList,alpha,beta)
			GeneralizedHistogramIntersectionKernelMatrixQ=GeneralizedHistogramIntersectionKernelFunction(JointQ_AttributeMatrix,
				AdverseInteractionTrainingList,alpha,beta)

			np.save(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixP'+'Alpha='+str(alpha)+'Beta='+str(beta),GeneralizedHistogramIntersectionKernelMatrixP)
			np.savetxt(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixP'+'Alpha='+str(alpha)+'Beta='+str(beta)+'.txt',GeneralizedHistogramIntersectionKernelMatrixP)

			np.save(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixQ'+'Alpha='+str(alpha)+'Beta='+str(beta),GeneralizedHistogramIntersectionKernelMatrixQ)
			np.savetxt(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixQ'+'Alpha='+str(alpha)+'Beta='+str(beta)+'.txt',GeneralizedHistogramIntersectionKernelMatrixQ)


def GeneralizedTStudentKernel1Function(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate Generalized T-Student Kernel1 Function
	# i.e., 1/(1+||X-Y||_1)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	GeneralizedTStudentKernel1Matrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		TempValue=np.absolute(DrugAttirbuteMatrix[DrugID1]-DrugAttirbuteMatrix[DrugID2])
		TempValue=1+np.sum(TempValue)
		GeneralizedTStudentKernel1Matrix[DrugID1,DrugID2]=1/TempValue
		GeneralizedTStudentKernel1Matrix[DrugID2,DrugID1]=GeneralizedTStudentKernel1Matrix[DrugID1,DrugID2]
	# GeneralizedTStudentKernel1Matrix=GeneralizedTStudentKernel1Matrix/GeneralizedTStudentKernel1Matrix.max()
	WhereIsNan=np.isnan(GeneralizedTStudentKernel1Matrix)
	GeneralizedTStudentKernel1Matrix[WhereIsNan]=0.0
	return GeneralizedTStudentKernel1Matrix


def OutputGeneralizedTStudentKernel1Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./GeneralizedTStudentKernel1Function/'
	MakeDir(Address)
	GeneralizedTStudentKernel1MatrixP=GeneralizedTStudentKernel1Function(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	GeneralizedTStudentKernel1MatrixQ=GeneralizedTStudentKernel1Function(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'GeneralizedTStudentKernel1MatrixP',GeneralizedTStudentKernel1MatrixP)
	np.savetxt(str(Address)+'GeneralizedTStudentKernel1MatrixP.txt',GeneralizedTStudentKernel1MatrixP)

	np.save(str(Address)+'GeneralizedTStudentKernel1MatrixQ',GeneralizedTStudentKernel1MatrixQ)
	np.savetxt(str(Address)+'GeneralizedTStudentKernel1MatrixQ.txt',GeneralizedTStudentKernel1MatrixQ)




def GeneralizedTStudentKernel2Function(DrugAttirbuteMatrix,AdverseInteractionTrainingList):
	# this function is to calculate Generalized T-Student Kernel1 Function
	# i.e., 1/(1+||X-Y||_1)
	DrugNum=np.shape(DrugAttirbuteMatrix)[0]
	DrugSimilartyMatrix=np.dot(DrugAttirbuteMatrix,DrugAttirbuteMatrix.transpose())
	DrugSimilartyMatrixDiag=np.diag(DrugSimilartyMatrix)
	FirstMatrix=np.zeros((DrugNum,DrugNum));SecondMatrix=np.zeros((DrugNum,DrugNum))
	FirstMatrix[:,0:DrugNum]=DrugSimilartyMatrixDiag.reshape(DrugNum,1)
	SecondMatrix[0:DrugNum,:]=DrugSimilartyMatrixDiag.reshape(1,DrugNum)
	TempMatrix=FirstMatrix+SecondMatrix-2*DrugSimilartyMatrix
	TempMatrix=1/(1+TempMatrix)

	GeneralizedTStudentKernel2Matrix=np.zeros((DrugNum,DrugNum))
	for AdverseInteractionSample in AdverseInteractionTrainingList:
		DrugID1=AdverseInteractionSample.DrugID1
		DrugID2=AdverseInteractionSample.DrugID2
		GeneralizedTStudentKernel2Matrix[DrugID1,DrugID2]=TempMatrix[DrugID1,DrugID2]
		GeneralizedTStudentKernel2Matrix[DrugID2,DrugID1]=GeneralizedTStudentKernel2Matrix[DrugID1,DrugID2]
	# GeneralizedTStudentKernel2Matrix=GeneralizedTStudentKernel2Matrix/GeneralizedTStudentKernel2Matrix.max()
	WhereIsNan=np.isnan(GeneralizedTStudentKernel2Matrix)
	GeneralizedTStudentKernel2Matrix[WhereIsNan]=0.0
	return GeneralizedTStudentKernel2Matrix

def OutputGeneralizedTStudentKernel2Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,
	AdverseInteractionTrainingList):
	Address='./GeneralizedTStudentKernel2Function/'
	MakeDir(Address)
	GeneralizedTStudentKernel2MatrixP=GeneralizedTStudentKernel2Function(P_CommonAttributeMatrix,
		AdverseInteractionTrainingList)
	GeneralizedTStudentKernel2MatrixQ=GeneralizedTStudentKernel2Function(JointQ_AttributeMatrix,
			AdverseInteractionTrainingList)
	np.save(str(Address)+'GeneralizedTStudentKernel2MatrixP',GeneralizedTStudentKernel2MatrixP)
	np.savetxt(str(Address)+'GeneralizedTStudentKernel2MatrixP.txt',GeneralizedTStudentKernel2MatrixP)

	np.save(str(Address)+'GeneralizedTStudentKernel2MatrixQ',GeneralizedTStudentKernel2MatrixQ)
	np.savetxt(str(Address)+'GeneralizedTStudentKernel2MatrixQ.txt',GeneralizedTStudentKernel2MatrixQ)


def LoadAllKernelMatricesIntoLists():
	# this function is to load all kernel Matrices
	KernelMatricesPList=[]
	KernelMatricesQList=[]

	# load LinearKernelFunction
	Address='./LinearKernelFunction/'
	LinearKernelMatrixP=np.load(str(Address)+'LinearKernelMatrixP.npy')
	LinearKernelMatrixQ=np.load(str(Address)+'LinearKernelMatrixQ.npy')
	KernelMatricesPList.append(LinearKernelMatrixP)
	KernelMatricesQList.append(LinearKernelMatrixQ)


	#load PolynomialKernelFunction
	Address='./PolynomialKernelFunction/'
	aSet=np.arange(0,5.02,1.0);aSet=np.round(aSet,2)
	bSet=np.arange(1,5.02,1.0); bSet=np.round(bSet,2)
	cSet=np.arange(0.5,2.1,0.5); cSet=np.round(cSet,2)
	for a in aSet:
		for b in bSet:
			for c in cSet:
				PolynomialKernelMatrixP=np.load(str(Address)+'PolynomialKernelMatrixP'+'a='+str(a)+'b='+str(b)+'c='+str(c)+'.npy')
				PolynomialKernelMatrixQ=np.load(str(Address)+'PolynomialKernelMatrixQ'+'a='+str(a)+'b='+str(b)+'c='+str(c)+'.npy')
				KernelMatricesPList.append(PolynomialKernelMatrixP)
				KernelMatricesQList.append(PolynomialKernelMatrixQ)

	# load GaussianKernelFunction
	Address='./GaussianKernelFunction/'
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		GaussianKernelMatrixP=np.load(str(Address)+'GaussianKernelMatrixP'+'Delta='+str(Delta)+'.npy')
		GaussianKernelMatrixQ=np.load(str(Address)+'GaussianKernelMatrixQ'+'Delta='+str(Delta)+'.npy')
		KernelMatricesPList.append(GaussianKernelMatrixP)
		KernelMatricesQList.append(GaussianKernelMatrixQ)

	# load ExponentialKernelFunction
	Address='./ExponentialKernelFunction/'
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		ExponentialKernelMatrixP=np.load(str(Address)+'ExponentialKernelMatrixP'+'Delta='+str(Delta)+'.npy')
		ExponentialKernelMatrixQ=np.load(str(Address)+'ExponentialKernelMatrixQ'+'Delta='+str(Delta)+'.npy')
		KernelMatricesPList.append(ExponentialKernelMatrixP)
		KernelMatricesQList.append(ExponentialKernelMatrixQ)


	# Load LaplacianKernelFunction
	Address='./LaplacianKernelFunction/'
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		LaplacianKernelMatrixP=np.load(str(Address)+'LaplacianKernelMatrixP'+'Delta='+str(Delta)+'.npy')
		LaplacianKernelMatrixQ=np.load(str(Address)+'LaplacianKernelMatrixQ'+'Delta='+str(Delta)+'.npy')
		KernelMatricesPList.append(LaplacianKernelMatrixP)
		KernelMatricesQList.append(LaplacianKernelMatrixQ)


	# Load SigmoidKernelFunction
	Address='./SigmoidKernelFunction/'
	aSet=[1e-8,5e-8,1e-7,5e-7,1e-6,5e-6,1e-5,5e-5,1e-4,5e-4,1e-3,5e-3]
	bSet=np.arange(0,2.01,0.5); bSet=np.round(bSet,2)
	for a in aSet:
		for b in bSet:
			SigmoidKernelMatrixP=np.load(str(Address)+'SigmoidKernelMatrixP'+'a='+str(a)+'b='+str(b)+'.npy')
			SigmoidKernelMatrixQ=np.load(str(Address)+'SigmoidKernelMatrixQ'+'a='+str(a)+'b='+str(b)+'.npy')
			KernelMatricesPList.append(SigmoidKernelMatrixP)
			KernelMatricesQList.append(SigmoidKernelMatrixQ)


	# Load RationalQuadraticKernelFunction
	Address='./RationalQuadraticKernelFunction/'
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		RationalQuadraticKernelMatrixP=np.load(str(Address)+'RationalQuadraticKernelMatrixP'+'c='+str(c)+'.npy')
		RationalQuadraticKernelMatrixQ=np.load(str(Address)+'RationalQuadraticKernelMatrixQ'+'c='+str(c)+'.npy')
		KernelMatricesPList.append(RationalQuadraticKernelMatrixP)
		KernelMatricesQList.append(RationalQuadraticKernelMatrixQ)


	# Load MultiquadricKernelFunction
	Address='./MultiquadricKernelFunction/'
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		MultiquadricKernelMatrixP=np.load(str(Address)+'MultiquadricKernelMatrixP'+'c='+str(c)+'.npy')
		MultiquadricKernelMatrixQ=np.load(str(Address)+'MultiquadricKernelMatrixQ'+'c='+str(c)+'.npy')
		KernelMatricesPList.append(MultiquadricKernelMatrixP)
		KernelMatricesQList.append(MultiquadricKernelMatrixQ)

	# Load InverseMultiquadricKernelFunction
	Address='./InverseMultiquadricKernelFunction/'
	cSet=np.arange(0,10.02,1.0); cSet=np.round(cSet,2)
	for c in cSet:
		InverseMultiquadricKernelMatrixP=np.load(str(Address)+'InverseMultiquadricKernelMatrixP'+'c='+str(c)+'.npy')
		InverseMultiquadricKernelMatrixQ=np.load(str(Address)+'InverseMultiquadricKernelMatrixQ'+'c='+str(c)+'.npy')
		KernelMatricesPList.append(InverseMultiquadricKernelMatrixP)
		KernelMatricesQList.append(InverseMultiquadricKernelMatrixQ)

	# # Load SphericalKernelFunction
	# Address='./SphericalKernelFunction/'
	# DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	# for Delta in DeltaSet:
	# 	SphericalKernelMatrixP=np.load(str(Address)+'SphericalKernelMatrixP'+'Delta='+str(Delta)+'.npy')
	# 	SphericalKernelMatrixQ=np.load(str(Address)+'SphericalKernelMatrixQ'+'Delta='+str(Delta)+'.npy')
	# 	KernelMatricesPList.append(SphericalKernelMatrixP)
	# 	KernelMatricesQList.append(SphericalKernelMatrixQ)


	# Load LogKernelFunction1
	Address='./LogKernelFunction1/'
	LogKernelFunction1MatrixP=np.load(str(Address)+'LogKernelFunction1MatrixP'+'.npy')
	LogKernelFunction1MatrixQ=np.load(str(Address)+'LogKernelFunction1MatrixQ'+'.npy')
	KernelMatricesPList.append(LogKernelFunction1MatrixP)
	KernelMatricesQList.append(LogKernelFunction1MatrixQ)

	# Load LogKernelFunction2
	Address='./LogKernelFunction2/'
	LogKernelFunction2MatrixP=np.load(str(Address)+'LogKernelFunction2MatrixP'+'.npy')
	LogKernelFunction2MatrixQ=np.load(str(Address)+'LogKernelFunction2MatrixQ'+'.npy')
	KernelMatricesPList.append(LogKernelFunction2MatrixP)
	KernelMatricesQList.append(LogKernelFunction2MatrixQ)


	# Load CauchyKernelFunction
	Address='./CauchyKernelFunction/'
	DeltaSet=[0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000]
	for Delta in DeltaSet:
		CauchyKernelMatrixP=np.load(str(Address)+'CauchyKernelMatrixP'+'Delta='+str(Delta)+'.npy')
		CauchyKernelMatrixQ=np.load(str(Address)+'CauchyKernelMatrixQ'+'Delta='+str(Delta)+'.npy')
		KernelMatricesPList.append(CauchyKernelMatrixP)
		KernelMatricesQList.append(CauchyKernelMatrixQ)

	# Load ChiSquareKernelFunction
	Address='./ChiSquareKernelFunction/'
	ChiSquareKernelMatrixP=np.load(str(Address)+'ChiSquareKernelMatrixP'+'.npy')
	ChiSquareKernelMatrixQ=np.load(str(Address)+'ChiSquareKernelMatrixQ'+'.npy')
	KernelMatricesPList.append(ChiSquareKernelMatrixP)
	KernelMatricesQList.append(ChiSquareKernelMatrixQ)

	# Load HistogramIntersectionKernelFunction
	Address='./HistogramIntersectionKernelFunction/'
	HistogramIntersectionKernelMatrixP=np.load(str(Address)+'HistogramIntersectionKernelMatrixP'+'.npy')
	HistogramIntersectionKernelMatrixQ=np.load(str(Address)+'HistogramIntersectionKernelMatrixQ'+'.npy')
	KernelMatricesPList.append(HistogramIntersectionKernelMatrixP)
	KernelMatricesQList.append(HistogramIntersectionKernelMatrixQ)

	# Load GeneralizedHistogramIntersectionKernelFunction
	Address='./GeneralizedHistogramIntersectionKernelFunction/'
	alphaSet=np.arange(0.1,2.01,0.2); alphaSet=np.round(alphaSet,2)
	betaSet=np.arange(0.1,2.01,0.2); betaSet=np.round(betaSet,2)
	for alpha in alphaSet:
		for beta in betaSet:
			GeneralizedHistogramIntersectionKernelMatrixP=np.load(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixP'+'Alpha='+str(alpha)+'Beta='+str(beta)+'.npy')
			GeneralizedHistogramIntersectionKernelMatrixQ=np.load(str(Address)+'GeneralizedHistogramIntersectionKernelMatrixQ'+'Alpha='+str(alpha)+'Beta='+str(beta)+'.npy')
			KernelMatricesPList.append(GeneralizedHistogramIntersectionKernelMatrixP)
			KernelMatricesQList.append(GeneralizedHistogramIntersectionKernelMatrixQ)

	# Load GeneralizedTStudentKernel1Function
	Address='./GeneralizedTStudentKernel1Function/'
	GeneralizedTStudentKernel1MatrixP=np.load(str(Address)+'GeneralizedTStudentKernel1MatrixP'+'.npy')
	GeneralizedTStudentKernel1MatrixQ=np.load(str(Address)+'GeneralizedTStudentKernel1MatrixQ'+'.npy')
	KernelMatricesPList.append(GeneralizedTStudentKernel1MatrixP)
	KernelMatricesQList.append(GeneralizedTStudentKernel1MatrixQ)


	# Load GeneralizedTStudentKernel2Function
	Address='./GeneralizedTStudentKernel2Function/'
	GeneralizedTStudentKernel2MatrixP=np.load(str(Address)+'GeneralizedTStudentKernel2MatrixP'+'.npy')
	GeneralizedTStudentKernel2MatrixQ=np.load(str(Address)+'GeneralizedTStudentKernel2MatrixQ'+'.npy')
	KernelMatricesPList.append(GeneralizedTStudentKernel2MatrixP)
	KernelMatricesQList.append(GeneralizedTStudentKernel2MatrixQ)

	return KernelMatricesPList,KernelMatricesQList

def CalculateSimilarityAmongKernelMatrices(KernelMatricesList):
	# this function is to calculate the Similarity among all kernel matrices of common
	# attribute representation (i.e., P) and specific attribute represention (i.e., Q)
	KernelMatricesNumber=len(KernelMatricesPList)
	# print(KernelMatricesNumber)
	KernelMatricesSimilarity=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
	for KernelIndex1 in range(KernelMatricesNumber):
		print(KernelIndex1)
		for KernelIndex2 in range(KernelMatricesNumber):
			if KernelIndex1>=KernelIndex2:
				continue
			KernelMatricesDiff=KernelMatricesList[KernelIndex1]-KernelMatricesList[KernelIndex2]
			KernelMatricesSimilarity[KernelIndex1,KernelIndex2]=np.linalg.norm(KernelMatricesDiff,ord=2)
			KernelMatricesSimilarity[KernelIndex2,KernelIndex1]=KernelMatricesSimilarity[KernelIndex1,KernelIndex2]
	return KernelMatricesSimilarity

def CalculateandSaveSimilarityAmongPandQKernelMatrice(KernelMatricesPList,KernelMatricesQList):
	# this function is to Calculate and Save Similarity Among P and 
	# Q Kernel Matrice into Files 
	# calculate SimilarityAmongKernelMatrices 
	KernelMatricesPSimilarity=CalculateSimilarityAmongKernelMatrices(KernelMatricesPList)
	KernelMatricesQSimilarity=CalculateSimilarityAmongKernelMatrices(KernelMatricesQList)
	# save SimilarityAmongKernelMatrices 

	Address='./KernelMatricesSimilarity/'
	MakeDir(Address)
	np.save(str(Address)+'KernelMatricesPSimilarity',KernelMatricesPSimilarity)
	np.savetxt(str(Address)+'KernelMatricesPSimilarity.txt',KernelMatricesPSimilarity)

	np.save(str(Address)+'KernelMatricesQSimilarity',KernelMatricesQSimilarity)
	np.savetxt(str(Address)+'KernelMatricesQSimilarity.txt',KernelMatricesQSimilarity)


def CalculateGListKernelMatrices(KernelMatricesList):
	# this function is to calculate list of G matrices of each kernel
	KernelMatricesNumber=len(KernelMatricesList)
	Glist=[]
	for Index in range(KernelMatricesNumber):
		# print(Index)
		GMatrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
		for KernelIndex1 in range(KernelMatricesNumber):
			FirstMatrix=KernelMatricesList[Index]-KernelMatricesList[KernelIndex1]
			for KernelIndex2 in range(KernelMatricesNumber):
				SecondMatrix=KernelMatricesList[Index]-KernelMatricesList[KernelIndex2]
				GMatrix[KernelIndex1,KernelIndex2]=np.sum(FirstMatrix*SecondMatrix)
				# GMatrix[KernelIndex1,KernelIndex2]=np.trace(np.dot(FirstMatrix,SecondMatrix.transpose()))
		Glist.append(GMatrix)
	return Glist

def SaveGlistToTXT(GMatrixList,Address,LabelPQ):
	# this function is to save the GList to Address
	MakeDir(Address)
	KernelMatricesNumber=len(GMatrixList)
	for Index in range(KernelMatricesNumber):
		np.save(str(Address)+str(LabelPQ)+'i='+str(Index),GMatrixList[Index])
		np.savetxt(str(Address)+str(LabelPQ)+'i='+str(Index)+'.txt',GMatrixList[Index])


def CountType(path):
	# return the type and the number of the type file in folder path 
	type_dict={}
	for root, dirs, files in os.walk(path):
		for name in files:
			type_dict.setdefault(os.path.splitext(name)[1],0)
			type_dict[os.path.splitext(name)[1]] += 1
	return type_dict


def LoadGlistFromTXT(Address,LabelPQ):
	# load Gmatrix of each kernel from memory
	type_dict=CountType(Address)
	KernelMatricesNumber=type_dict['.npy']
	Glist=[]
	for Index in range(KernelMatricesNumber):
		GMatrix=np.load(str(Address)+str(LabelPQ)+'i='+str(Index)+'.npy')
		Glist.append(GMatrix)
	return Glist

def ReturnDiagonalMatrixofInverseRowL2Norm(InputMatrix):
	# this function is to return a Diagonal matrix, its Diagonal elements 
	# are the inverse of the L2 norm of each row of InputMatrix
	L2NormofRowVector=2*np.linalg.norm(InputMatrix,ord=None,axis=1)
	InverseL2NormofRowVector=1/L2NormofRowVector
	D_InputMatrix=np.diag(InverseL2NormofRowVector)
	return D_InputMatrix

def LearningProcessforY_MatrixParamaterUpdate(GMatrixListP,GMatrixListQ,AssembleDMatrix):
	KernelMatricesNumber=len(GMatrixListP)
	LambdaSet=[0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000,5000,10000]
	# LambdaSet=[1e-7,5e-7,1e-6,5e-6,1e-5,5e-5,0.0001,0.0005,0.001,0.005,0.01,0.05,0.1]
	# if AssembleDMatrix is not normalized use the above LambdaSet
	# AssembleDMatrix=AssembleDMatrix/AssembleDMatrix.max()

	MuSet=[0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000,5000,10000]
	# fileOut=open('LambdaMuDiscussion'+'.txt','a')
	# print('Lambda\tMu\tLoss',file=fileOut)
	LambdaSet=[0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000,5000,10000]

	LambdaSet=[0.001]
	MuSet=[10]
	Address='./LambdaMuAndY_Matrix/'
	MakeDir(Address)
	for Lambda in LambdaSet:
		for Mu in MuSet:
			same_seeds(1)
			Y_Matrix=np.random.rand(KernelMatricesNumber,KernelMatricesNumber)
			Y_Matrix=Y_Matrix+np.diag(-np.diag(Y_Matrix))
			Hat_Y_Matrix=deepcopy(Y_Matrix)
			Hat_Hat_Y_Matrix=deepcopy(Y_Matrix)

			Lambda1_Y_Matrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
			Lambda2_Y_Matrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))			
			DeltaMatrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
			Rou_1=0.01
			Rou_2=0.01
			Max_Rou=100000
			tau=1.01
			MaxIter=35
			LossLast=1e50
			for Iter in range(MaxIter):
				# first update matrix Y_Matrix by column
				RightMatrix=Rou_1*Hat_Y_Matrix-Lambda1_Y_Matrix+Rou_2*Hat_Hat_Y_Matrix-Lambda2_Y_Matrix-\
					Lambda*AssembleDMatrix
				# print(RightMatrix)
				for Index in range(KernelMatricesNumber):
					GMatrix=GMatrixListP[Index]+GMatrixListQ[Index]
					RightMatrixVector=RightMatrix[:,Index:Index+1]
					LeftMatrix=2*GMatrix+(Rou_1+Rou_2)*np.eye(KernelMatricesNumber)
					Y_Matrix[:,Index:Index+1]=np.dot(np.linalg.inv(LeftMatrix),RightMatrixVector)

				Y_Matrix=Y_Matrix+np.diag(-np.diag(Y_Matrix))
				# WhereIsNan=np.isnan(Y_Matrix)
				# Y_Matrix[WhereIsNan]=0.0

				# second update Matrix Hat_Y_Matrix
				D_Inverse_Hat_Y_Matrix=ReturnDiagonalMatrixofInverseRowL2Norm(Hat_Y_Matrix)
				RightMatrix=Rou_1*Y_Matrix+Lambda1_Y_Matrix
				LeftMatrix=2*Mu*D_Inverse_Hat_Y_Matrix+Rou_1*np.eye(KernelMatricesNumber)
				Hat_Y_Matrix=np.dot(np.linalg.inv(LeftMatrix),RightMatrix)

				# thirdly update Matrix Hat_Hat_Y_Matrix
				TempMatrix=Y_Matrix+Lambda2_Y_Matrix/Rou_2
				ALlOnesVector=np.ones((KernelMatricesNumber,1))
				ALLOneMatrix=np.dot(ALlOnesVector,ALlOnesVector.transpose())/KernelMatricesNumber
				V_Matrix=TempMatrix-np.dot(ALLOneMatrix,TempMatrix)+ALLOneMatrix

				# updeta vector ColumnAverage_DeltaMatrix i.e., the average value
				# for each column of matrix DeltaMatrix
				ColumnAverage_DeltaMatrix=np.sum(DeltaMatrix,axis=0)/KernelMatricesNumber
				for Index in range(KernelMatricesNumber):
					Iterations=10
					V_Matrix_IndexColumn=V_Matrix[:,Index]
					for Iteration in range(Iterations):
						TempVector=ColumnAverage_DeltaMatrix[Index]-V_Matrix_IndexColumn
						TempVector=np.where(TempVector>=0,TempVector,0)
						UpValue=np.sum(TempVector)/KernelMatricesNumber-ColumnAverage_DeltaMatrix[Index]
						DownValue=np.sum(TempVector>0)/KernelMatricesNumber-1
						ColumnAverage_DeltaMatrix[Index]=ColumnAverage_DeltaMatrix[Index]-UpValue/DownValue
				
				Hat_Hat_Y_Matrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
				Position=np.where(DeltaMatrix==0)
				TempMatrix=np.dot(ALlOnesVector,ColumnAverage_DeltaMatrix.reshape(1,KernelMatricesNumber))
				Hat_Hat_Y_Matrix[Position]=V_Matrix[Position]-TempMatrix[Position]
				Hat_Hat_Y_Matrix=np.where(Hat_Hat_Y_Matrix>=0,Hat_Hat_Y_Matrix,np.zeros_like(Hat_Hat_Y_Matrix))

				DeltaMatrix=np.zeros((KernelMatricesNumber,KernelMatricesNumber))
				Position=np.where(Hat_Hat_Y_Matrix==0)
				DeltaMatrix[Position]=TempMatrix[Position]-V_Matrix[Position]
				DeltaMatrix=np.where(DeltaMatrix>=0,DeltaMatrix,np.zeros_like(DeltaMatrix))


				# update Lambda1_Y_Matrix  Lambda2_Y_Matrix
				Lambda1_Y_Matrix=Lambda1_Y_Matrix+Rou_1*(Y_Matrix-Hat_Y_Matrix)
				Lambda2_Y_Matrix=Lambda2_Y_Matrix+Rou_2*(Y_Matrix-Hat_Hat_Y_Matrix)
				# update Rou_1 Rou_2
				Rou_1=min(tau*Rou_1,Max_Rou)
				Rou_2=min(tau*Rou_2,Max_Rou)
				
				LossValue=0
				for Index in range(KernelMatricesNumber):
					Y_Matrix_IndexColumn=Y_Matrix[:,Index:Index+1]
					LossValue=LossValue+np.dot(Y_Matrix_IndexColumn.transpose(),
						np.dot(GMatrixListP[Index]+GMatrixListQ[Index],Y_Matrix_IndexColumn))
				LossValue=LossValue+Lambda*np.sum(AssembleDMatrix*Hat_Hat_Y_Matrix)+Mu*np.sum(
					np.linalg.norm(Hat_Y_Matrix,axis=1))
				print('Iteration Number is %d, Loss is %.3f' %(Iter,LossValue))
				if LossValue-LossLast>4*LossLast: 
					break
				LossLast=LossValue
				Hat_Hat_Y_MatrixLast3=Hat_Hat_Y_Matrix

			# print(np.linalg.norm(Hat_Hat_Y_Matrix,axis=1))
			# np.save('L2_1Norm_Hat_Hat_Y_Matrix'+'Lambda='+str(Lambda)+'Mu='+str(Mu),np.linalg.norm(Hat_Hat_Y_Matrix,axis=1))
			# np.save('Row_Sum_Hat_Hat_Y_Matrix'+'Lambda='+str(Lambda)+'Mu='+str(Mu),np.sum(Hat_Hat_Y_Matrix,axis=1))
			
			# print(np.sum(np.linalg.norm(Hat_Hat_Y_Matrix,axis=1)<=0.05)/np.shape(Hat_Y_Matrix)[0])
			# print('Lambda=%f\tMu=%f\tLoss=%.10f' %(Lambda,Mu,LossLast))
			# print('Lambda=%f\tMu=%f\tLoss=%.10f' %(Lambda,Mu,LossLast),file=fileOut)
			np.save(str(Address)+'Lambda='+str(Lambda)+'Mu='+str(Mu)+'Y_Matrix3',Hat_Hat_Y_MatrixLast3)
			np.savetxt(str(Address)+'Lambda='+str(Lambda)+'Mu='+str(Mu)+'Y_Matrix3.txt',Hat_Hat_Y_MatrixLast3)
	# 		fileOut.flush()
	# fileOut.close()

class KernelFunctionIndex:
    def __init__(self,KernelFunctionNumber,KernelFunctionWeight):
        self.KernelFunctionNumber = KernelFunctionNumber
        self.KernelFunctionWeight = KernelFunctionWeight

def ConvertMatrixListTo3DTensor(KernelMatricesList):
	# this function is to convert KernelMatricesPList and KernelMatricesQList into
	# 3D tensor for the conveince of reconstructing kernel vector of adverse drug pair
	KernelMatricesNumber=len(KernelMatricesPList)
	DrugNum=np.shape(KernelMatricesList[0])[0]
	KernelMatricesTensor=np.zeros((KernelMatricesNumber,DrugNum,DrugNum))
	for Index in range(KernelMatricesNumber):
		KernelMatricesTensor[Index,:,:]=KernelMatricesList[Index]
	return KernelMatricesTensor

def GetRepresentativeKernelIndexSet(UsedKernelSet):
	RepresentativeKernelIndexSet=[]
	for Kernel in UsedKernelSet:
		RepresentativeKernelIndexSet.append(Kernel.KernelFunctionNumber)
	return RepresentativeKernelIndexSet


# this function is to convert a float matrix into a binary matrix. To be specific, if 
# a element is higher than the threshold, we set it to be 1, otherwise set it to be 0
def ConvertBinaryMatrix(TempMatrix,GroundTruthAdverseInteractionOfTestingSet):
# Input: TempMatrix is the matrix to be converted
	RowNum,ColumnNum=np.shape(TempMatrix)
	TempMatrix[GroundTruthAdverseInteractionOfTestingSet>=Threshold_PredictADDI]=\
		TempMatrix[GroundTruthAdverseInteractionOfTestingSet>Threshold_PredictADDI]/1
	TempMatrixConvertedBinary=np.where(TempMatrix>=Threshold_PredictADDI,1,
		np.zeros_like(TempMatrix))
	return TempMatrixConvertedBinary


def EvaluationModuleForComputingSevenMetrics(GroundTruthAdverseInteractionOfTestingSet,
	PredictedAdverseInteractionOfTestingSet):
	# print(type(GroundTruthAdverseInteractionOfTestingSet))
	GroundTruthAdverseInteractionOfTestingSet=np.array(GroundTruthAdverseInteractionOfTestingSet)
	Pos=GroundTruthAdverseInteractionOfTestingSet>=Threshold_PredictADDI
	PredictedAdverseInteractionOfTestingSet=np.array(PredictedAdverseInteractionOfTestingSet)
	# print(type(GroundTruthAdverseInteractionOfTestingSet))
	PredictedAdverseInteractionOfTestingSet[Pos]=PredictedAdverseInteractionOfTestingSet[Pos]/0.4
	PredictedAdverseInteractionOfTestingSetBinary=ConvertBinaryMatrix(PredictedAdverseInteractionOfTestingSet,
		GroundTruthAdverseInteractionOfTestingSet)
	PredictedAdverseInteractionOfTestingSetBinary=np.asnumpy(PredictedAdverseInteractionOfTestingSetBinary)
	GroundTruthAdverseInteractionOfTestingSet=np.asnumpy(GroundTruthAdverseInteractionOfTestingSet)
	# convert PredictedAdverseInteractionOfTestingSet into a binary matrix by function ConvertBinaryMatrix
	tn, fp, fn, tp =confusion_matrix(GroundTruthAdverseInteractionOfTestingSet.flatten(),
		PredictedAdverseInteractionOfTestingSetBinary.flatten()).ravel()
	# we first flatten the ground-truth Adverse Interaction matrix of testing samples and the predicted Adverse Interaction 
	# matrix of testing samples into Vectors and then use confusion_matrix function to calculate tn, fp, fn, tp values of 
	# confusion matrix. To be specific, tn refers to true negative (0 is predicted as 0), fp refers to false positive (0 is 
	# predicted as 1), tp refers to true positive (1 is predicted as 1), and fn refers to false negative (1 is predicted as 0)
	AUC=roc_auc_score(GroundTruthAdverseInteractionOfTestingSet.flatten(),
		PredictedAdverseInteractionOfTestingSetBinary.flatten())
	# call function roc_auc_score to estimate the AUC value of the model 
	# here, we also have to flatten matrices GroundTruthAdverseInteractionOfTestingSet
	# and PredictedAdverseInteractionOfTestingSetBinary into Vectors
	AUPR= average_precision_score(GroundTruthAdverseInteractionOfTestingSet.flatten(),
		PredictedAdverseInteractionOfTestingSetBinary.flatten())
	# call function average_precision_score to calculate the AUPR value of the model
	# here, we also have to flatten matrices GroundTruthAdverseInteractionOfTestingSet
	# and PredictedAdverseInteractionOfTestingSetBinary into Vectors
	Specificity=tn/(tn+fp)
	Accuracy=(tp+tn)/(tp+tn+fp+fn)
	Precision=tp/(tp+fp)
	Recall=tp/(tp+fn)
	F_score=2*Precision*Recall/(Precision+Recall)
	# compute metrics Specificity,Accuracy,Precision,Recall,F_score based on the values
	# of tn, fp, fn, tp
	return Specificity,Precision,Recall,F_score,Accuracy,AUC,AUPR


def UseKernelWeightandKernelMatricestoRepresentDrugInteractionVector(AdverseInteractionTrainingList,
	AdverseInteractionTestingList,KernelMatricesPList,KernelMatricesQList):
	# since we use 384 kernel function to calculate the similarity of attribute 
	# representations for each adverse drug pair and we obtain matrix Y to denote
	# the probability of one kernel to represent the other, this function is to exploit 
	# the  matrix Y and original 384 kernel matrices to reformulate each kernel function
	# i.e., 384 kernel matrices can be reconstructed by themselves
	# with self-representation probability matrix Y so as to get the final representation of 
	# of each adverse drug pair
	KernelMatricesNumber=len(KernelMatricesPList)
	PercentageSet=np.arange(0.02,0.61,0.02)
	# discuss the number of kernels as the representative kernels
	NumberTopKernel=(PercentageSet*KernelMatricesNumber).astype(int)

	# 需要把KernelMatricesPList和KernelMatricesQList中的对应位置药物间的核相似性
	# 核拼接成向量，i.e., each adverse drug pair can be represented by the kernel 
	# similarity vector with 372 kernels
	KernelMatricesPTensor=ConvertMatrixListTo3DTensor(KernelMatricesPList)
	KernelMatricesQTensor=ConvertMatrixListTo3DTensor(KernelMatricesQList)

	fileOut=open('ADDIPredictionResults'+'.txt','a')
	print('Lambda\tMu\tUsedTopKernel\tSpecificity\tPrecision\tF_score\tAccuracy\tAUC\tAUPR',file=fileOut)


	Address='./LambdaMuAndY_Matrix/'
	LambdaSet=[0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000,5000,10000]
	MuSet=[0.0001,0.0005,0.001,0.005,0.01,0.05,0.1,0.5,1,5,10,50,100,500,1000,5000,10000]
	NumberTopKernel=(PercentageSet*KernelMatricesNumber).astype(int)

	LambdaSet=[0.001]	
	MuSet=[10]
	NumberTopKernel=[66]

	for Lambda in LambdaSet:
		for Mu in MuSet:
			Address='./LambdaMuAndY_Matrix/'
			Final_Y_Matrix=np.load(str(Address)+'Lambda='+str(Lambda)+'Mu='+str(Mu)+'Y_Matrix3'+'.npy')
			KernelWeight=np.sum(Final_Y_Matrix,axis=1)
			# print(KernelWeight)
			KernelFunctionList=[]
			for Index in range(KernelMatricesNumber):
				Temp=KernelFunctionIndex(Index,KernelWeight[Index])
				KernelFunctionList.append(Temp)
			KernelFunctionList.sort(reverse=True,key= lambda x:x.KernelFunctionWeight)

			# sort the kernels by their weight
			for UsedTopKernel in NumberTopKernel:
				UsedTopKernel=(int)(UsedTopKernel)
				UsedKernelSet=KernelFunctionList[0:UsedTopKernel]
				RepresentativeKernelIndexSet=GetRepresentativeKernelIndexSet(UsedKernelSet)
				# print(RepresentativeKernelIndexSet)
				# kernel Index and kernel weight
				# use the UsedTopKernel number of kernels as the representitive ones 
				GMatrixListPConstruted=[]
				GMatrixListQConstruted=[]
				since=time.time()
				for Index in range(KernelMatricesNumber):
					RepresentativePSum=np.zeros((np.shape(KernelMatricesPList[0])))
					RepresentativeQSum=np.zeros((np.shape(KernelMatricesQList[0])))
					for RepresentativeKernelIndex in RepresentativeKernelIndexSet:
						RepresentativePSum=RepresentativePSum+\
							Final_Y_Matrix[RepresentativeKernelIndex,Index]*KernelMatricesPTensor[RepresentativeKernelIndex,:,:]
						RepresentativeQSum=RepresentativeQSum+\
							Final_Y_Matrix[RepresentativeKernelIndex,Index]*KernelMatricesQTensor[RepresentativeKernelIndex,:,:]
	
					RepresentativePSum=KernelWeight[Index]*RepresentativePSum
					RepresentativeQSum=KernelWeight[Index]*RepresentativeQSum

					GMatrixListPConstruted.append(RepresentativePSum)
					GMatrixListQConstruted.append(RepresentativeQSum)
				KernelMatricesPConstrutedTensor=ConvertMatrixListTo3DTensor(GMatrixListPConstruted)
				KernelMatricesQConstrutedTensor=ConvertMatrixListTo3DTensor(GMatrixListQConstruted)
				time_elapsed = time.time() - since
				# print('Training Times=%.3f' %(time_elapsed))				
				for AdverseInteractionSample in AdverseInteractionTrainingList:
					DrugID1=AdverseInteractionSample.DrugID1
					DrugID2=AdverseInteractionSample.DrugID2
					AdverseVector=AdverseInteractionSample.AdverseInteractionVector
					KernelVectorP=KernelMatricesPConstrutedTensor[:,DrugID1,DrugID2]
					KernelVectorQ=KernelMatricesQConstrutedTensor[:,DrugID1,DrugID2]
					KernelVectorPQ=np.hstack((KernelVectorP,KernelVectorQ))
					AdverseInteractionSample.AddKernelVectorbyRepresentativeKernels(KernelVectorPQ)

				for AdverseInteractionSample in AdverseInteractionTestingList:
					DrugID1=AdverseInteractionSample.DrugID1
					DrugID2=AdverseInteractionSample.DrugID2
					AdverseVector=AdverseInteractionSample.AdverseInteractionVector
					KernelVectorP=KernelMatricesPConstrutedTensor[:,DrugID1,DrugID2]
					KernelVectorQ=KernelMatricesQConstrutedTensor[:,DrugID1,DrugID2]
					KernelVectorPQ=np.hstack((KernelVectorP,KernelVectorQ))
					AdverseInteractionSample.AddKernelVectorbyRepresentativeKernels(KernelVectorPQ)

				LearningRate=0.0001
				Weight_Decay=0.0000001
				same_seeds(27)
				DimensionofAdverseInteraction=len(AdverseVector)
				DimentionofInputKernelVector=len(KernelVectorPQ)
				# print(DimensionofAdverseInteraction,DimentionofInputKernelVector)
				ADDIModelingNeuralNetwork=DeepNeuralNetworkForADDIModeling(DimentionofInputKernelVector,
					DimensionofAdverseInteraction).cuda()

				Option_DeepNeuralNetwork=torch.optim.Adam(ADDIModelingNeuralNetwork.parameters(),
					eps=1e-10,lr=LearningRate,weight_decay=Weight_Decay)
				ADDIModelingNeuralNetwork.train()
				MaxIter=10
				for Iter in range(MaxIter):
					# for each iteration
					# index records the number of row in FinalAttributeVectorOfTrainingSamples
					# to be specific, the final attribute representation of the index-th sample 
					# in AdverseInteractionTrainingList is FinalAttributeVectorOfTrainingSamples[index]
					# print('%d Iterations For Training Deep Network Network: for Lambda=%f Mu=%f UsedTopKernel=%d' 
					# 		%(Iter,Lambda,Mu,UsedTopKernel))	
					Lossss=0
					print('%d Iteration for Training' %(Iter))
					for ADDISample in AdverseInteractionTrainingList:
					# traverse each sample in the training set AdverseInteractionTrainingList
						DrugID1=ADDISample.DrugID1
						DrugID2=ADDISample.DrugID2
						# print('%d Iterations For Training Deep Network Network: Adverse Drug Pair (%d, %d) for Lambda=%f Mu=%f UsedTopKernel=%d' 
						# 	%(Iter,DrugID1,DrugID2,Lambda,Mu,UsedTopKernel))	
						AdverseInteractionVector=torch.Tensor(ADDISample.AdverseInteractionVector).cuda()
						KernelVectorPQ=torch.Tensor(ADDISample.KernelVectorPQ).cuda()
						PredictedKernelVectorPQ=ADDIModelingNeuralNetwork(KernelVectorPQ)

						ADDIModelingNeuralNetworkLoss=LossFunctionOfPredictedAndGroundTruthAdverseInteractionVector(
							PredictedKernelVectorPQ,AdverseInteractionVector)

						Lossss=Lossss+ADDIModelingNeuralNetworkLoss
						Option_DeepNeuralNetwork.zero_grad()
						# ADDIModelingNeuralNetworkLoss.backward(retain_graph=True)
						ADDIModelingNeuralNetworkLoss.backward(retain_graph=True)

						Option_DeepNeuralNetwork.step()
					print(Lossss)		
				Address='./DeepNeuralNetwork/'
				MakeDir(Address)
				save_path_DeepNeuralNetwork=str(Address)+'DeepNeuralNetworkLambda='+\
					str(Lambda)+'Mu='+str(Mu)+'UsedKernel'+str(UsedTopKernel)+'.txt'
				torch.save(ADDIModelingNeuralNetwork.state_dict(), save_path_DeepNeuralNetwork)
				print('The Deep Neural Network Has Been Trained Completely for Lambda=%f Mu=%f UsedTopKernel=%d !!!'
						%(Lambda,Mu,UsedTopKernel))
			
				## ADDIModelingNeuralNetworkPredict=ADDIModelingNeuralNetwork
				## ADDIModelingNeuralNetworkPredict.eval()

				Address='./DeepNeuralNetwork/'
				DimensionofAdverseInteraction=len(AdverseVector)
				DimentionofInputKernelVector=len(KernelVectorPQ)
				save_path_DeepNeuralNetwork=str(Address)+'DeepNeuralNetworkLambda='+\
					str(Lambda)+'Mu='+str(Mu)+'UsedKernel'+str(UsedTopKernel)+'.txt'
				ADDIModelingNeuralNetworkPredict=DeepNeuralNetworkForADDIModeling(DimentionofInputKernelVector,
					DimensionofAdverseInteraction).cuda()
				ADDIModelingNeuralNetworkPredict.load_state_dict(torch.load(save_path_DeepNeuralNetwork))	
				ADDIModelingNeuralNetworkPredict.eval()
		
				print('Testing Module for Predicting Adverse Interactions in Testing Dataset for Lambda=%f Mu=%f UsedTopKernel=%d !!!'
						%(Lambda,Mu,UsedTopKernel))
				GroundTruthAdverseInteractionOfTestingSet=torch.empty(size=[1,DimensionofAdverseInteraction]).cuda()
				# Initialize a set to record the ground-truth adverse interactions of the testing samples
				PredictedAdverseInteractionOfTestingSet=torch.empty(size=[1,DimensionofAdverseInteraction]).cuda()
				# Initialize a set to record the predicted adverse interactions of the testing samples

				for ADDISample in AdverseInteractionTestingList:
					DrugID1=ADDISample.DrugID1
					DrugID2=ADDISample.DrugID2
					AdverseInteractionVector=torch.Tensor(ADDISample.AdverseInteractionVector).cuda()
					KernelVectorPQ=torch.Tensor(ADDISample.KernelVectorPQ).cuda()
					PredictedKernelVectorPQ=ADDIModelingNeuralNetworkPredict(KernelVectorPQ)
					AdverseInteractionVector=AdverseInteractionVector.view(1,-1)
					PredictedKernelVectorPQ=PredictedKernelVectorPQ.view(1,-1)
					GroundTruthAdverseInteractionOfTestingSet=torch.cat((GroundTruthAdverseInteractionOfTestingSet,
						AdverseInteractionVector),0).cuda()
					PredictedAdverseInteractionOfTestingSet=torch.cat((PredictedAdverseInteractionOfTestingSet,
						PredictedKernelVectorPQ),0).cuda()
					# print('Testing Module: Predicting Adverse Interaction Vector of Adverse Drug Pair (%d, %d) for Lambda=%f Mu=%f UsedTopKernel=%d' 
					# 	%(DrugID1, DrugID2,Lambda,Mu,UsedTopKernel))
				GroundTruthAdverseInteractionOfTestingSet=GroundTruthAdverseInteractionOfTestingSet[torch.arange(
					GroundTruthAdverseInteractionOfTestingSet.size(0))!=0]
				# remove the first random vector from GroundTruthAdverseInteractionOfTestingSet and maintain the last 2-
				# len(AdverseInteractionTestingList) of the ground-truth Adverse Interaction Vector of testing samples
				PredictedAdverseInteractionOfTestingSet=PredictedAdverseInteractionOfTestingSet[torch.arange(
					PredictedAdverseInteractionOfTestingSet.size(0))!=0]
				# remove the first random vector from PredictedAdverseInteractionOfTestingSet and maintain the last 2-
				# len(AdverseInteractionTestingList) of the predicted Adverse Interaction Vector of testing samples

				GroundTruthAdverseInteractionOfTestingSet=GroundTruthAdverseInteractionOfTestingSet.cpu().detach().numpy()
				PredictedAdverseInteractionOfTestingSet=PredictedAdverseInteractionOfTestingSet.cpu().detach().numpy()
				
				# convert tensor GroundTruthAdverseInteractionOfTestingSet and PredictedAdverseInteractionOfTestingSet 
				# into numpy for evaluation
				Specificity,Precision,Recall,F_score,Accuracy,AUC,AUPR=EvaluationModuleForComputingSevenMetrics(
					GroundTruthAdverseInteractionOfTestingSet,PredictedAdverseInteractionOfTestingSet)
				print('Lambda=%f Mu=%f UsedTopKernel=%f Specificity=%f Precision=%f F-score=%f Accuracy=%f AUC=%f AUPR=%f' 
					%(Lambda,Mu, UsedTopKernel, Specificity,Precision,Recall,Accuracy,AUC,AUPR))

				print('Lambda=%f\tMu=%f\tUsedTopKernel=%f\tSpecificity=%f\tPrecision=%f\tF-score=%f\tAccuracy=%f\tAUC=%f\tAUPR=%f' 
					%(Lambda,Mu, UsedTopKernel,Specificity,Precision,Recall,Accuracy,AUC,AUPR), file=fileOut)

				fileOut.flush()
	fileOut.close()


if __name__ == '__main__':

	
	P_CommonAttributeMatrixAddress='./SharedSpecificAttributeRepresentations/P_CommonAttributeMatrix.npy'
	P_CommonAttributeMatrix=LoadP_CommonAttributeMatrixInNPYform(P_CommonAttributeMatrixAddress)

	Q_MolecularStructureAddress='./SharedSpecificAttributeRepresentations/Q_MolecularStructure.npy'
	Q_MolecularStructureMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_MolecularStructureAddress)

	Q_TargetAddress='./SharedSpecificAttributeRepresentations/Q_Target.npy'
	Q_TargetMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_TargetAddress)

	Q_PathwayAddress='./SharedSpecificAttributeRepresentations/Q_Pathway.npy'
	Q_PathwayMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_PathwayAddress)

	Q_SideEffectAddress='./SharedSpecificAttributeRepresentations/Q_SideEffect.npy'
	Q_SideEffectMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_SideEffectAddress)

	Q_PhenotypeAddress='./SharedSpecificAttributeRepresentations/Q_Phenotype.npy'
	Q_PhenotypeMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_PhenotypeAddress)

	Q_GeneAddress='./SharedSpecificAttributeRepresentations/Q_Gene.npy'
	Q_GeneMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_GeneAddress)

	Q_DiseaseAddress='./SharedSpecificAttributeRepresentations/Q_Disease.npy'
	Q_DiseaseMatrix=LoadQ_SpecificAttributeMatrixInNPYform(Q_DiseaseAddress)


	AdverseInteractionDatasetAddress='./AdverseInteraction/AdverseInteractionSetfromTWOSIDES.txt'
	AdverseInteractionDataset=LoadAdverseInteractionData(AdverseInteractionDatasetAddress)
	# print(len(AdverseInteractionDataset))
	
	Q_AttributeMatrix=[Q_MolecularStructureMatrix,Q_TargetMatrix,Q_PathwayMatrix,Q_SideEffectMatrix,Q_PhenotypeMatrix,Q_GeneMatrix,Q_DiseaseMatrix]

	JointQ_AttributeMatrix=JointQ_SpecificAttributeofAllDrugs(Q_AttributeMatrix)

	# # Linear Kernel Function
	# print("Generating a linear Kernels...")
	# OutputLinearKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# Polynomial Kernel Function
	print("Generating 120 Polynomial Kernels...")
	OutputPolynomialKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)
	
	# # Gaussian Kernel Function
	# print("Generating 13 Gaussian Kernels...")
	# OutputGaussianKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Exponential Kernel Function
	# print("Generating 13 Exponential Kernels...")
	# OutputExponentialKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Laplacian Kernel Function
	# print("Generating 13 Laplacian Kernels...")
	# OutputLaplacianKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Sigmoid Kernel Function
	# print("Generating 60 Sigmoid Kernels...")
	# OutputSigmoidKernellMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Rational Quadratic Function
	# print("Generating 11 Rational Quadratic Kernels...")
	# OutputRationalQuadraticKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)
	
	# # Multiquadric Kernel Function
	# print("Generating 11 Multiquadric Kernels...")
	# OutputMultiquadricKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Inverse Multiquadric Kernel Function
	# print("Generating 11 Inverse Multiquadric Kernels...")
	# OutputInverseMultiquadricKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Log Kernel Function1
	# print("Generating a Log_1 Kernels...")
	# OutputLogKernelFunction1Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Log Kernel Function2
	# print("Generating a Log_2 Kernels...")
	# OutputLogKernelFunction2Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Cauchy Kernel Function
	# print("Generating 13 Cauchy Kernels...")
	# OutputCauchyKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # ChiSquareKernel Function 
	# print("Generating a Chi Square Kernels...")
	# OutputChiSquareKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Histogram Intersection Kernel Function
	# print("Generating a Histogram Kernels...")
	# OutputHistogramIntersectionKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Generalized Histogram Intersection Kernel Function
	# print("Generating 100 Generalized Kernels...")
	# OutputGeneralizedHistogramIntersectionKernelMatrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Generalized TStudentKernel1 Function
	# print("Generating a Generalized TStudent_1 Kernels...")
	# OutputGeneralizedTStudentKernel1Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)

	# # Generalized TStudent Kernel2 Function
	# print("Generating a Generalized TStudent_2 Kernels...")
	# OutputGeneralizedTStudentKernel2Matrix(P_CommonAttributeMatrix,JointQ_AttributeMatrix,AdverseInteractionDataset)


	print("Loading Kernel Matrices...")
	KernelMatricesPList,KernelMatricesQList=LoadAllKernelMatricesIntoLists()
	print("Kernel Matrices have been Loaded")
	# print(len(KernelMatricesPList))
	print("Kernel Number is %d " %(len(KernelMatricesPList)))

	# print("CalculeteSimilarityAmongPKernelMatriceQKernelMatrice...")
	# CalculateandSaveSimilarityAmongPandQKernelMatrice(KernelMatricesPList,KernelMatricesQList)


	# load SimilarityAmongKernelMatrices
	print("Loading Kernel Similarity...")
	Address='./KernelMatricesSimilarity/'
	KernelMatricesPSimilarity=np.load(str(Address)+'KernelMatricesPSimilarity.npy')
	KernelMatricesQSimilarity=np.load(str(Address)+'KernelMatricesQSimilarity.npy')
	AssembleDMatrix=KernelMatricesPSimilarity+KernelMatricesQSimilarity
	print("Kernel Similarity have been Loaded")


	# # Calculate and Save GMatrix of shared attribute representation P 
	# # and specific attribute reoresentation Q to txt and npy
	# print("Calculate and save GMatrix of shared attribute representation PMatrix")
	# GMatrixListP=CalculateGListKernelMatrices(KernelMatricesPList)
	# SaveGlistToTXT(GMatrixListP,'./GMatrixListP/','PMatrix')

	# print("Calculate and save GMatrix of specific attribute representation QMatrix")
	# GMatrixListQ=CalculateGListKernelMatrices(KernelMatricesQList)
	# SaveGlistToTXT(GMatrixListQ,'./GMatrixListQ/','QMatrix')



	print("Loading GMatrixList for each Kernel...")
	# load GMatrix of commom attribute representation P 
	# and specific attribute reoresentation Q from npy 
	GMatrixListP=LoadGlistFromTXT('./GMatrixListP/','PMatrix')
	GMatrixListQ=LoadGlistFromTXT('./GMatrixListQ/','QMatrix')
	print("GMatrixList for each Kernel have been Loaded")


	print("Optimaze Kernel Correlation Matrix Y of Kernal Matrices...")
	# Learning Reconstruction Matrix Y of Kernal Matrices
	LearningProcessforY_MatrixParamaterUpdate(GMatrixListP,GMatrixListQ,AssembleDMatrix)
	# all matrices Y_Matrix have been output

	AdverseInteractionTrainingList,AdverseInteractionTestingList=RandomTrainingSampleAndTestingSampleSeletion(AdverseInteractionDataset,0.9)
	# print(len(AdverseInteractionTrainingList),len(AdverseInteractionTestingList))

	print("Training the deep neural Network for Multi-attribute multi-kernel ADDI prediction...")
	UseKernelWeightandKernelMatricestoRepresentDrugInteractionVector(AdverseInteractionTrainingList,
		AdverseInteractionTestingList,KernelMatricesPList,KernelMatricesQList)

	





